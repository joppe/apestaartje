import { Animator } from '@apestaartje/animation/animator/Animator';
import { Chronometer } from '@apestaartje/animation/animator/Chronometer';
import { Stage } from '@apestaartje/animation/stage/Stage';

import { fromTemplate } from './snake/generate/fromTemplate';
import { isSamePosition } from './snake/map/isSamePosition';
import { Direction } from './snake/move/Direction';
import { Renderer } from './snake/render/Renderer';
import { Score } from './snake/score/Score';
import { State, Status } from './snake/status/Status';

/**
 * The snake game
 *
 * The game consists of a map (walls), a snake and food.
 * The snake moves around the map and eats food.
 * The snake grows when it eats food.
 * The game is over when the snake hits a wall or itself.
 *
 * The game is generated by using a template. Them map is rendered in a separate layer, because it does not change.
 */

export type AppOptions = {
  template: string;
  wallChar: string;
  snakeChar: string;
  foodChar: string;
  blockSize: number;
  container: HTMLElement;
};

export function app({
  template,
  wallChar,
  snakeChar,
  foodChar,
  blockSize,
  container,
}: AppOptions): void {
  const renderer = new Renderer({
    blockSize,
    colors: { wall: '#964B00', snake: '#f00', candy: '#0f0', text: '#000' },
  });
  const { map, snake, candy } = fromTemplate({
    renderer,
    template,
    wallChar,
    snakeChar,
    foodChar,
  });
  const score = new Score({
    renderer,
    position: { row: map.rows + 1, column: 0 },
  });
  const status = new Status({
    renderer,
    position: { row: 5, column: 5 },
  });

  if (snake === undefined || candy === undefined) {
    throw new Error('Snake or candy not found');
  }

  const stage = new Stage({
    width: blockSize * map.columns,
    height: blockSize * (map.rows + 2),
  });

  const background = stage.createLayer('background', 10);
  const foreground = stage.createLayer('foreground', 20);

  background.freeze(true);
  background.addAsset(map, 'map', 10);

  foreground.addAsset(candy, 'candy', 10);
  foreground.addAsset(snake, 'snake', 20);
  foreground.addAsset(score, 'score', 30);
  foreground.addAsset(status, 'status', 40);

  window.addEventListener('keydown', (event: KeyboardEvent): void => {
    switch (event.code) {
      case 'Space':
        status.state = State.RUNNING;
        break;
      case 'ArrowUp':
        snake.direction = Direction.Up;
        break;
      case 'ArrowRight':
        snake.direction = Direction.Right;
        break;
      case 'ArrowDown':
        snake.direction = Direction.Down;
        break;
      case 'ArrowLeft':
        snake.direction = Direction.Left;
        break;
    }
  });

  const animator = new Animator((time: Chronometer): boolean => {
    if (status.state === State.RUNNING) {
      stage.tick(time);

      // Check if eating itself
      if (snake.isEatingItSelf()) {
        snake.undo();
        status.state = State.GAME_OVER;
      }

      // Check colission with wall
      if (map.isWall(snake.position)) {
        snake.undo();
        status.state = State.GAME_OVER;
      }

      // Check if eating candy
      if (isSamePosition(snake.position, candy.position)) {
        snake.grow(3);
        candy.reSpawn(map.randomFreePosition());
        score.increase();
      }
    }

    stage.render();

    return true;
  });

  container.appendChild(stage.element);

  animator.start();
}
